<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DVC Viewer ‚Äî Pipeline Visualization</title>
    <meta name="description" content="Interactive DAG visualization for DVC pipelines">

    <!-- Cytoscape.js + Dagre layout -->
    <script src="https://unpkg.com/cytoscape@3.30.4/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --bg-card: rgba(17, 24, 39, 0.8);
            --bg-glass: rgba(255, 255, 255, 0.03);
            --border: rgba(255, 255, 255, 0.06);
            --border-glow: rgba(99, 102, 241, 0.3);
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --accent: #6366f1;
            --accent-glow: rgba(99, 102, 241, 0.15);

            /* State colors */
            --state-valid: #10b981;
            --state-valid-bg: rgba(16, 185, 129, 0.1);
            --state-valid-glow: rgba(16, 185, 129, 0.35);
            --state-rerun: #fde047;
            --state-rerun-bg: rgba(253, 224, 71, 0.12);
            --state-rerun-glow: rgba(253, 224, 71, 0.4);
            --state-failed: #f43f5e;
            --state-failed-bg: rgba(244, 63, 94, 0.1);
            --state-failed-glow: rgba(244, 63, 94, 0.45);
            --state-never: #64748b;
            --state-never-bg: rgba(100, 116, 139, 0.1);
            --state-never-glow: rgba(100, 116, 139, 0.25);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        /* ‚îÄ‚îÄ‚îÄ Header ‚îÄ‚îÄ‚îÄ */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 56px;
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-logo {
            font-size: 20px;
            filter: drop-shadow(0 0 8px var(--accent-glow));
        }

        .header-title {
            font-size: 15px;
            font-weight: 600;
            letter-spacing: -0.01em;
        }

        .header-subtitle {
            font-size: 12px;
            color: var(--text-muted);
            font-weight: 400;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        /* ‚îÄ‚îÄ‚îÄ Legend ‚îÄ‚îÄ‚îÄ */
        .legend {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            box-shadow: 0 0 8px currentColor;
        }

        .legend-dot.valid {
            background: var(--state-valid);
            color: var(--state-valid);
        }

        .legend-dot.rerun {
            background: var(--state-rerun);
            color: var(--state-rerun);
        }

        .legend-dot.never {
            background: var(--state-never);
            color: var(--state-never);
        }

        .legend-dot.failed {
            background: var(--state-failed);
            color: var(--state-failed);
        }

        .legend-dot.frozen,
        .status-badge.frozen {
            background: rgba(56, 189, 248, 0.15);
            color: #38bdf8;
            border: 1px solid rgba(56, 189, 248, 0.3);
        }

        /* ‚îÄ‚îÄ‚îÄ Main layout ‚îÄ‚îÄ‚îÄ */
        .main {
            display: flex;
            height: calc(100vh - 56px);
            margin-top: 56px;
        }

        /* ‚îÄ‚îÄ‚îÄ Graph container ‚îÄ‚îÄ‚îÄ */
        .graph-container {
            flex: 1;
            position: relative;
            background:
                radial-gradient(circle at 20% 30%, rgba(99, 102, 241, 0.04) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(34, 197, 94, 0.03) 0%, transparent 50%),
                var(--bg-primary);
        }

        /* Grid pattern */
        .graph-container::before {
            content: '';
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
        }

        #cy {
            width: 100%;
            height: 100%;
        }

        /* ‚îÄ‚îÄ‚îÄ Stats bar ‚îÄ‚îÄ‚îÄ */
        .stats-bar {
            position: absolute;
            bottom: 16px;
            left: 16px;
            display: flex;
            gap: 8px;
        }

        .stat-chip {
            background: var(--bg-card);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 6px 14px;
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stat-chip .count {
            font-weight: 600;
            color: var(--text-primary);
        }

        /* ‚îÄ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ‚îÄ */
        .sidebar {
            width: 380px;
            min-width: 260px;
            max-width: 80vw;
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .sidebar-resize-handle {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: col-resize;
            z-index: 10;
            background: transparent;
            transition: background 0.15s ease;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.active {
            background: var(--accent);
        }

        .sidebar.collapsed {
            transform: translateX(100%);
        }

        .sidebar-header {
            padding: 20px 20px 16px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-stage-name {
            font-size: 18px;
            font-weight: 600;
            letter-spacing: -0.02em;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            word-break: break-all;
        }

        .state-badge {
            font-size: 11px;
            font-weight: 500;
            padding: 3px 10px;
            border-radius: 100px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .state-badge.valid {
            background: var(--state-valid-bg);
            color: var(--state-valid);
            box-shadow: 0 0 12px var(--state-valid-glow);
        }

        .state-badge.needs_rerun {
            background: var(--state-rerun-bg);
            color: var(--state-rerun);
            box-shadow: 0 0 12px var(--state-rerun-glow);
        }

        .state-badge.never_run {
            background: var(--state-never-bg);
            color: var(--state-never);
        }

        .state-badge.failed {
            background: var(--state-failed-bg);
            color: var(--state-failed);
            box-shadow: 0 0 12px var(--state-failed-glow);
            border: 1px solid var(--state-failed);
        }


        .sidebar-command {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--text-secondary);
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 12px;
            word-break: break-all;
            margin-top: 8px;
        }

        /* ‚îÄ‚îÄ‚îÄ Sidebar sections ‚îÄ‚îÄ‚îÄ */
        .sidebar-content {
            padding: 0;
            flex: 1;
        }

        .sidebar-section {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-section:last-child {
            border-bottom: none;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
            margin-bottom: 10px;
        }

        .file-list {
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .file-item {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--text-secondary);
            padding: 6px 10px;
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 6px;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            word-break: break-all;
            overflow-wrap: break-word;
        }

        .file-item:hover {
            background: var(--accent-glow);
            border-color: var(--border-glow);
            color: var(--text-primary);
        }

        .file-item .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .file-item .status-dot.current {
            background: var(--state-valid);
            box-shadow: 0 0 6px var(--state-valid-glow);
        }

        .file-item .status-dot.outdated {
            background: var(--state-rerun);
            box-shadow: 0 0 6px var(--state-rerun-glow);
        }

        .file-item .status-dot.missing {
            background: #ef4444;
            box-shadow: 0 0 6px rgba(239, 68, 68, 0.4);
        }

        .file-item .status-dot.unknown {
            background: var(--state-never);
            box-shadow: 0 0 6px var(--state-never-glow);
        }

        .file-item.status-current {
            border-left: 3px solid var(--state-valid);
        }

        .file-item.status-outdated {
            border-left: 3px solid var(--state-rerun);
        }

        .file-item.status-missing {
            border-left: 3px solid #ef4444;
        }

        .file-item.status-unknown {
            border-left: 3px solid var(--state-never);
        }

        .file-item.param::before {
            content: '‚öôÔ∏è ';
            font-size: 11px;
        }

        .file-item.metric::before {
            content: 'üìä ';
            font-size: 11px;
        }

        .file-item.plot::before {
            content: 'üìà ';
            font-size: 11px;
        }

        /* ‚îÄ‚îÄ‚îÄ Empty sidebar ‚îÄ‚îÄ‚îÄ */
        .sidebar-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 40px;
            text-align: center;
        }

        .sidebar-empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.4;
        }

        .sidebar-empty-text {
            font-size: 14px;
            color: var(--text-muted);
            line-height: 1.6;
        }

        /* ‚îÄ‚îÄ‚îÄ Loading state ‚îÄ‚îÄ‚îÄ */
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            transition: opacity 0.5s ease;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .loading-text {
            margin-top: 16px;
            font-size: 14px;
            color: var(--text-muted);
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* ‚îÄ‚îÄ‚îÄ Error state ‚îÄ‚îÄ‚îÄ */
        .error-container {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            padding: 40px;
            text-align: center;
        }

        .error-icon {
            font-size: 56px;
            margin-bottom: 16px;
        }

        .error-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .error-message {
            font-size: 14px;
            color: var(--text-muted);
            max-width: 400px;
        }

        /* ‚îÄ‚îÄ‚îÄ Tooltip on graph ‚îÄ‚îÄ‚îÄ */
        .cy-tooltip {
            position: absolute;
            background: var(--bg-card);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 12px;
            color: var(--text-primary);
            pointer-events: none;
            z-index: 50;
            white-space: nowrap;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transform: translate(-50%, -100%);
            margin-top: -12px;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .cy-tooltip.visible {
            opacity: 1;
        }

        /* ‚îÄ‚îÄ‚îÄ Fit button ‚îÄ‚îÄ‚îÄ */
        .controls {
            position: absolute;
            top: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .ctrl-btn {
            width: 36px;
            height: 36px;
            background: var(--bg-card);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-secondary);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .ctrl-btn:hover {
            background: var(--accent-glow);
            border-color: var(--border-glow);
            color: var(--text-primary);
        }

        /* ‚îÄ‚îÄ‚îÄ Clickable file items ‚îÄ‚îÄ‚îÄ */
        .file-item.inspectable {
            cursor: pointer;
            position: relative;
            padding-right: 36px;
        }

        .file-item.inspectable::after {
            content: 'üîç';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 16px;
            opacity: 0.4;
            transition: all 0.2s ease;
        }

        .file-item.inspectable.has-update::after {
            opacity: 1;
            animation: inspect-pulse 1.5s ease-in-out infinite;
        }

        .file-item.inspectable:hover {
            background: var(--accent-glow);
            border-color: var(--accent);
        }

        .file-item.inspectable:hover::after {
            opacity: 1;
            animation: none;
            transform: translateY(-50%) scale(1.15);
        }

        @keyframes inspect-pulse {

            0%,
            100% {
                transform: translateY(-50%) scale(1);
                filter: drop-shadow(0 0 0 rgba(99, 102, 241, 0));
            }

            50% {
                transform: translateY(-50%) scale(1.25);
                filter: drop-shadow(0 0 6px rgba(99, 102, 241, 0.6));
            }
        }

        /* Node badges on graph (pulsating magnifying glass) */
        .node-badge {
            position: absolute;
            z-index: 100;
            pointer-events: none;
            font-size: 18px;
            line-height: 1;
            animation: node-badge-pulse 1.5s ease-in-out infinite;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        @keyframes node-badge-pulse {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
                filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 0 rgba(99, 102, 241, 0));
            }

            50% {
                transform: translate(-50%, -50%) scale(1.3);
                filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(99, 102, 241, 0.7));
            }
        }

        /* ‚îÄ‚îÄ‚îÄ Inspector Modal ‚îÄ‚îÄ‚îÄ */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            z-index: 500;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 32px;
            animation: fadeIn 0.2s ease;
        }

        .modal-overlay.visible {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            width: 90vw;
            max-width: 1200px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 24px 80px rgba(0, 0, 0, 0.6);
            overflow: hidden;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 24px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .modal-title {
            font-size: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-title-icon {
            font-size: 18px;
        }

        .modal-file-badge {
            font-size: 11px;
            font-weight: 400;
            padding: 2px 8px;
            border-radius: 6px;
            background: var(--accent-glow);
            color: var(--accent);
            border: 1px solid var(--border-glow);
            text-transform: uppercase;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .modal-close:hover {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        .modal-toolbar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 24px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .modal-search {
            flex: 1;
            max-width: 300px;
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 6px 12px;
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            outline: none;
            transition: border-color 0.15s ease;
        }

        .modal-search:focus {
            border-color: var(--border-glow);
        }

        .modal-search::placeholder {
            color: var(--text-muted);
        }

        .modal-stats {
            font-size: 12px;
            color: var(--text-muted);
        }

        .modal-body {
            flex: 1;
            overflow: auto;
            padding: 0;
        }

        /* ‚îÄ‚îÄ‚îÄ CSV Table ‚îÄ‚îÄ‚îÄ */
        .csv-table-wrap {
            overflow: auto;
            max-height: 100%;
        }

        .csv-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .csv-table th {
            position: sticky;
            top: 0;
            background: var(--bg-primary);
            padding: 10px 14px;
            text-align: left;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            border-bottom: 2px solid var(--border);
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
            z-index: 10;
        }

        .csv-table th:hover {
            color: var(--text-primary);
        }

        .csv-table th .sort-arrow {
            margin-left: 4px;
            font-size: 10px;
            opacity: 0.4;
        }

        .csv-table th.sorted .sort-arrow {
            opacity: 1;
            color: var(--accent);
        }

        .csv-table td {
            padding: 8px 14px;
            border-bottom: 1px solid var(--border);
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            white-space: nowrap;
        }

        .csv-table tr:hover td {
            background: var(--bg-glass);
            color: var(--text-primary);
        }

        .csv-table td.numeric {
            text-align: right;
            color: var(--accent);
        }

        /* ‚îÄ‚îÄ‚îÄ Image viewer ‚îÄ‚îÄ‚îÄ */
        .image-viewer {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 32px;
            min-height: 300px;
        }

        .image-viewer img {
            max-width: 100%;
            max-height: 70vh;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        /* ‚îÄ‚îÄ‚îÄ PDF viewer ‚îÄ‚îÄ‚îÄ */
        .pdf-viewer {
            width: 100%;
            height: 100%;
            min-height: 70vh;
        }

        .pdf-viewer iframe {
            width: 100%;
            height: 70vh;
            border: none;
        }

        /* ‚îÄ‚îÄ‚îÄ Text viewer ‚îÄ‚îÄ‚îÄ */
        .text-viewer {
            padding: 20px 24px;
            white-space: pre-wrap;
            word-break: break-all;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        /* ‚îÄ‚îÄ‚îÄ File not found ‚îÄ‚îÄ‚îÄ */
        .file-not-found {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px;
            text-align: center;
        }

        .file-not-found-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.4;
        }

        .file-not-found-text {
            font-size: 14px;
            color: var(--text-muted);
        }

        .file-not-found-path {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 8px;
            padding: 6px 12px;
            background: var(--bg-glass);
            border-radius: 6px;
        }

        /* ‚îÄ‚îÄ‚îÄ Scrollbar ‚îÄ‚îÄ‚îÄ */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* ‚îÄ‚îÄ‚îÄ Run Buttons ‚îÄ‚îÄ‚îÄ */
        .run-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border: 1px solid var(--border-glow);
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(139, 92, 246, 0.15));
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .run-btn:hover {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(139, 92, 246, 0.3));
            border-color: #818cf8;
            box-shadow: 0 0 12px rgba(99, 102, 241, 0.3);
            transform: translateY(-1px);
        }

        .run-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .run-btn.running {
            animation: pulse-glow 1.5s ease-in-out infinite;
        }

        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow: 0 0 8px rgba(99, 102, 241, 0.2);
            }

            50% {
                box-shadow: 0 0 20px rgba(99, 102, 241, 0.5);
            }
        }

        .stop-btn {
            display: none;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border: 1px solid var(--state-failed);
            border-radius: 8px;
            background: var(--state-failed-bg);
            color: var(--state-failed);
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .stop-btn:hover {
            background: rgba(244, 63, 94, 0.25);
            box-shadow: 0 0 12px var(--state-failed-glow);
            transform: translateY(-1px);
        }

        .stop-btn.visible {
            display: inline-flex;
        }

        .run-btn-sidebar {
            width: 100%;
            justify-content: center;
            margin-top: 12px;
            padding: 10px 16px;
        }

        .run-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            display: none;
        }

        .run-btn.running .run-spinner {
            display: inline-block;
        }

        .run-btn.running .run-icon {
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* ‚îÄ‚îÄ‚îÄ Execution Toast (small status indicator) ‚îÄ‚îÄ‚îÄ */
        .exec-toast {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 2000;
            background: var(--bg-card);
            border: 1px solid var(--border-glow);
            border-radius: 12px;
            padding: 10px 16px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            color: var(--text-primary);
            gap: 10px;
            align-items: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(12px);
            transition: all 0.3s ease;
        }

        .exec-toast.running {
            cursor: pointer;
        }

        .exec-toast.running:hover {
            transform: translateY(-2px);
            border-color: var(--accent-primary);
            background: var(--bg-card-elevated);
        }

        .exec-toast.active {
            display: flex;
        }

        .exec-toast .toast-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(99, 102, 241, 0.3);
            border-top-color: #818cf8;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        .exec-toast .toast-icon {
            font-size: 16px;
        }

        .exec-toast .toast-text {
            font-weight: 500;
        }

        .exec-toast.success {
            border-color: rgba(52, 211, 153, 0.4);
        }

        .exec-toast.error {
            border-color: rgba(239, 68, 68, 0.4);
        }

        /* ‚îÄ‚îÄ‚îÄ Sidebar Execution Logs ‚îÄ‚îÄ‚îÄ */
        .sidebar-logs {
            margin-top: 12px;
            padding: 16px 20px;
            border-top: 1px solid var(--border);
        }

        .sidebar-logs-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .sidebar-logs-title {
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
        }

        .sidebar-logs-duration {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--accent);
            margin-left: 8px;
            font-weight: 500;
        }

        .sidebar-logs-copy {
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-muted);
            font-size: 10px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .sidebar-logs-copy:hover {
            background: var(--accent-glow);
            color: var(--text-primary);
        }

        .sidebar-logs-content {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            line-height: 1.6;
            color: var(--text-secondary);
            white-space: pre-wrap;
            word-break: break-word;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px 12px;
            max-height: 300px;
            overflow-y: auto;
            margin: 0;
        }

        .sidebar-logs-empty {
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            color: var(--text-muted);
            font-style: italic;
            padding: 8px 0;
        }

        /* ‚îÄ‚îÄ‚îÄ Sidebar Node List ‚îÄ‚îÄ‚îÄ */
        .sidebar-node-list-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .sidebar-node-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .sidebar-node-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 14px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
            color: var(--text-primary);
        }

        .sidebar-node-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
            transform: translateX(4px);
        }

        .sidebar-node-item.next-up {
            border-color: #a855f7;
            background: rgba(168, 85, 247, 0.08);
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.1);
        }

        .sidebar-node-item.next-up:hover {
            background: rgba(168, 85, 247, 0.12);
        }

        .sidebar-node-item.frozen {
            border-color: rgba(56, 189, 248, 0.3);
            background: rgba(56, 189, 248, 0.05);
        }

        .sidebar-node-item.frozen .node-name {
            color: #38bdf8;
        }

        .sidebar-node-item.frozen {
            border-color: rgba(56, 189, 248, 0.3);
        }

        .sidebar-node-item.frozen .node-name {
            color: #38bdf8;
        }

        .sidebar-node-item .node-name {
            flex: 1;
            font-family: 'JetBrains Mono', monospace;
            white-space: normal;
            word-break: break-all;
        }

        .sidebar-node-item .node-status-badge {
            font-size: 10px;
            text-transform: uppercase;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 6px;
            letter-spacing: 0.02em;
        }

        .sidebar-node-item .node-status-badge.valid {
            background: rgba(52, 211, 153, 0.15);
            color: #34d399;
        }

        .sidebar-node-item .node-status-badge.needs_rerun {
            background: rgba(251, 191, 36, 0.15);
            color: #fbbf24;
        }

        .sidebar-node-item .node-status-badge.never_run {
            background: rgba(156, 163, 175, 0.15);
            color: #9ca3af;
        }

        .sidebar-node-item .node-status-badge.running {
            background: rgba(129, 140, 248, 0.15);
            color: #818cf8;
            animation: pulse-opacity 1.5s ease-in-out infinite;
        }

        .sidebar-node-item .node-status-badge.failed {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
        }

        @keyframes pulse-opacity {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        .sidebar-list-header {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--text-muted);
            letter-spacing: 0.05em;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sidebar-list-header::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255, 255, 255, 0.05);
        }

        /* ‚îÄ‚îÄ‚îÄ Error state on nodes ‚îÄ‚îÄ‚îÄ */
        .cy-node-error {
            border-color: #ef4444 !important;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.6) !important;
        }

        /* ‚îÄ‚îÄ‚îÄ Version Navigation ‚îÄ‚îÄ‚îÄ */
        .version-nav {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 8px 20px;
            background: rgba(30, 41, 59, 0.6);
            border-bottom: 1px solid var(--border);
            font-family: 'Inter', sans-serif;
            font-size: 12px;
        }

        .version-nav.active {
            display: flex;
        }

        .version-nav-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-glass);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.15s ease;
        }

        .version-nav-btn:hover:not(:disabled) {
            background: var(--accent-glow);
            border-color: var(--border-glow);
            color: var(--text-primary);
        }

        .version-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* ‚îÄ‚îÄ‚îÄ Commit Navigation ‚îÄ‚îÄ‚îÄ */
        .commit-nav {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 20px;
            padding-left: 20px;
            border-left: 1px solid var(--border);
        }

        .commit-nav-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-glass);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.15s ease;
            flex-shrink: 0;
        }

        .commit-nav-btn:hover:not(:disabled) {
            background: var(--accent-glow);
            border-color: var(--border-glow);
            color: var(--text-primary);
        }

        .commit-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .commit-nav-info {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 0;
        }

        .commit-hash {
            font-family: 'JetBrains Mono', 'SF Mono', monospace;
            font-size: 12px;
            color: var(--accent);
            background: rgba(99, 102, 241, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .commit-message {
            font-size: 12px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        .commit-badge-head {
            font-size: 10px;
            font-weight: 600;
            color: #10b981;
            background: rgba(16, 185, 129, 0.15);
            padding: 1px 6px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            flex-shrink: 0;
        }

        .commit-badge-history {
            font-size: 10px;
            font-weight: 600;
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.15);
            padding: 1px 6px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            flex-shrink: 0;
        }

        /* Dim run buttons when in history mode */
        .history-mode .run-btn,
        .history-mode .stop-btn {
            opacity: 0.3;
            pointer-events: none;
        }

        .version-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }

        .version-commit-msg {
            color: var(--text-primary);
            font-weight: 500;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .version-commit-meta {
            color: var(--text-muted);
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .version-counter {
            color: var(--text-muted);
            font-size: 11px;
            white-space: nowrap;
            font-family: 'JetBrains Mono', monospace;
        }

        .version-current-badge {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            background: rgba(99, 102, 241, 0.2);
            color: #818cf8;
            letter-spacing: 0.05em;
        }

        /* ‚îÄ‚îÄ‚îÄ Hydra Config Accordion ‚îÄ‚îÄ‚îÄ */
        .accordion {
            border-bottom: 1px solid var(--border);
        }

        .accordion-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 20px;
            cursor: pointer;
            user-select: none;
            transition: background 0.15s ease;
        }

        .accordion-header:hover {
            background: var(--bg-glass);
        }

        .accordion-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .accordion-header .section-title {
            margin-bottom: 0;
        }

        .accordion-chevron {
            font-size: 12px;
            color: var(--text-muted);
            transition: transform 0.25s ease;
        }

        .accordion.open .accordion-chevron {
            transform: rotate(90deg);
        }

        .accordion-body {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .accordion.open .accordion-body {
            max-height: 2000px;
        }

        .accordion-content {
            padding: 0 20px 16px;
        }

        .hydra-config-path {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .hydra-config-path .path-text {
            opacity: 0.7;
        }

        /* Parameter groups */
        .hydra-group {
            margin-bottom: 6px;
        }

        .hydra-group-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--accent);
            padding: 8px 0 4px;
            border-bottom: 1px solid rgba(99, 102, 241, 0.15);
            margin-bottom: 4px;
        }

        /* Parameter rows */
        .hydra-param {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .hydra-param:last-child {
            border-bottom: none;
        }

        .hydra-param-key {
            flex: 0 0 auto;
            max-width: 50%;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .hydra-param-input {
            flex: 1;
            min-width: 0;
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 4px 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            outline: none;
            transition: border-color 0.15s ease, background 0.15s ease;
        }

        .hydra-param-input:focus {
            border-color: var(--border-glow);
            background: rgba(0, 0, 0, 0.4);
            color: var(--text-primary);
        }

        .hydra-param-input.modified {
            border-color: rgba(251, 191, 36, 0.5);
            background: rgba(251, 191, 36, 0.06);
        }

        .hydra-param-type {
            flex: 0 0 auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 4px;
            background: rgba(99, 102, 241, 0.1);
            color: var(--text-muted);
            letter-spacing: 0.03em;
        }

        /* Boolean toggle */
        .hydra-toggle {
            position: relative;
            width: 34px;
            height: 18px;
            flex: 0 0 34px;
            cursor: pointer;
        }

        .hydra-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .hydra-toggle-track {
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 9px;
            transition: background 0.2s ease;
        }

        .hydra-toggle input:checked+.hydra-toggle-track {
            background: rgba(34, 197, 94, 0.5);
        }

        .hydra-toggle-thumb {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.2s ease;
        }

        .hydra-toggle input:checked~.hydra-toggle-thumb {
            transform: translateX(16px);
        }

        /* list display (read-only) */
        .hydra-list-value {
            flex: 1;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-muted);
            font-style: italic;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* null display */
        .hydra-null-value {
            flex: 1;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-muted);
            opacity: 0.5;
            font-style: italic;
        }

        .hydra-actions {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
            gap: 10px;
        }

        .hydra-save-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border: 1px solid var(--border-glow);
            border-radius: 6px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.12), rgba(139, 92, 246, 0.12));
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .hydra-save-btn:hover {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.25), rgba(139, 92, 246, 0.25));
            border-color: #818cf8;
        }

        .hydra-save-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .hydra-save-btn.saved {
            border-color: rgba(34, 197, 94, 0.5);
            background: rgba(34, 197, 94, 0.12);
            color: var(--state-valid);
        }

        .hydra-status {
            font-size: 11px;
            color: var(--text-muted);
            font-family: 'Inter', sans-serif;
        }

        .hydra-status.unsaved {
            color: var(--state-rerun);
        }

        .hydra-status.error {
            color: #ef4444;
        }

        .hydra-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            color: var(--text-muted);
            font-size: 12px;
            gap: 8px;
        }

        .hydra-loading .mini-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        .sidebar-search-container {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 8px;
        }

        .sidebar-search-input {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            outline: none;
            transition: all 0.2s ease;
        }

        .sidebar-status-filter {
            width: 100px;
            padding: 8px 4px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 12px;
            outline: none;
            cursor: pointer;
        }

        .sidebar-status-filter option {
            background: #1e293b;
            color: white;
        }

        .sidebar-search-input:focus,
        .sidebar-status-filter:focus {
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.12);
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
        }
    </style>
</head>

<body>

    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <span class="header-logo">üîç</span>
            <div>
                <div class="header-title">DVC Viewer</div>
                <div class="header-subtitle">Pipeline Visualization</div>
            </div>
            <div class="commit-nav" id="commit-nav" style="display:none;">
                <button class="commit-nav-btn" id="commit-older" title="Older commit">‚óÄ</button>
                <div class="commit-nav-info">
                    <span class="commit-badge-head" id="commit-badge">HEAD</span>
                    <span class="commit-hash" id="commit-hash"></span>
                    <span class="commit-message" id="commit-msg"></span>
                </div>
                <button class="commit-nav-btn" id="commit-newer" title="Newer commit">‚ñ∂</button>
            </div>
        </div>
        <div class="header-right">
            <div class="legend">
                <div class="legend-item">
                    <span class="legend-dot valid"></span>
                    Valid
                </div>
                <div class="legend-item">
                    <span class="legend-dot rerun"></span>
                    Needs rerun
                </div>
                <div class="legend-item">
                    <span class="legend-dot never"></span>
                    Never run
                </div>
                <div class="legend-item">
                    <span class="legend-dot failed"></span>
                    Failed
                </div>
                <div class="legend-item">
                    <span class="legend-dot frozen"></span>
                    Frozen
                </div>
            </div>
        </div>
        <button class="run-btn" id="btn-run-all" title="Run entire pipeline">
            <span class="run-icon">‚ñ∂</span>
            <span class="run-spinner"></span>
            Run All
        </button>
        <button class="stop-btn" id="btn-stop" title="Stop running pipeline">‚ñ† Stop</button>
        </div>
    </header>

    <!-- Main -->
    <main class="main">
        <!-- Graph -->
        <div class="graph-container">
            <div id="cy"></div>
            <div id="node-badges-layer"
                style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;overflow:hidden;">
            </div>

            <!-- Controls -->
            <div class="controls">
                <button class="ctrl-btn" id="btn-fit" title="Fit to viewport">‚ä°</button>
                <button class="ctrl-btn" id="btn-zoom-in" title="Zoom in">+</button>
                <button class="ctrl-btn" id="btn-zoom-out" title="Zoom out">‚àí</button>
            </div>

            <!-- Stats -->
            <div class="stats-bar" id="stats-bar"></div>

            <!-- Tooltip -->
            <div class="cy-tooltip" id="tooltip"></div>

            <!-- Loading -->
            <div class="loading-overlay" id="loading">
                <div class="loading-spinner"></div>
                <div class="loading-text">Loading pipeline‚Ä¶</div>
            </div>
        </div>

        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-resize-handle" id="sidebar-resize"></div>
            <div class="sidebar-empty" id="sidebar-empty">
                <div class="sidebar-search-container">
                    <input type="search" id="sidebar-search" class="sidebar-search-input"
                        placeholder="Search stages...">
                    <select id="sidebar-status-filter" class="sidebar-status-filter">
                        <option value="all">All</option>
                        <option value="valid">Valid</option>
                        <option value="needs_rerun">Changed</option>
                        <option value="never_run">Never Run</option>
                        <option value="frozen">Frozen</option>
                        <option value="running">Running</option>
                        <option value="failed">Failed</option>
                    </select>
                </div>
                <div class="sidebar-node-list-container" id="sidebar-node-list-container">
                    <div class="sidebar-list-header">Pipeline stages</div>
                    <ul class="sidebar-node-list" id="sidebar-node-list">
                        <!-- Populated by JS -->
                    </ul>
                </div>
            </div>
            <div id="sidebar-detail" style="display: none;">
                <div class="sidebar-header">
                    <div class="sidebar-stage-name">
                        <span id="detail-name"></span>
                        <span class="state-badge" id="detail-badge"></span>
                    </div>
                    <div class="sidebar-command" id="detail-cmd"></div>
                </div>
                <div class="sidebar-content" id="detail-sections"></div>
                <button class="run-btn run-btn-sidebar" id="btn-run-stage" title="Run this stage">
                    <span class="run-icon">‚ñ∂</span>
                    <span class="run-spinner"></span>
                    Run Stage
                </button>
                <button class="run-btn run-btn-sidebar" id="btn-freeze-stage" title="Freeze/Unfreeze this stage"
                    style="margin-top: 8px; border-color: #60a5fa; background: rgba(96, 165, 250, 0.1);">
                    <span class="freeze-icon">‚ùÑÔ∏è</span>
                    <span class="freeze-text">Freeze</span>
                </button>

                <div id="sidebar-logs-container"></div>
            </div>
        </aside>
    </main>

    <!-- Execution Toast -->
    <div class="exec-toast" id="exec-toast">
        <div class="toast-spinner" id="toast-spinner"></div>
        <span class="toast-icon" id="toast-icon" style="display:none;"></span>
        <span class="toast-text" id="toast-text">Running pipeline‚Ä¶</span>
    </div>

    <!-- File Inspector Modal -->
    <div class="modal-overlay" id="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">
                    <span class="modal-title-icon" id="modal-icon">üìÑ</span>
                    <span id="modal-filename">file.csv</span>
                    <span class="modal-file-badge" id="modal-badge">CSV</span>
                </div>
                <button class="modal-close" id="modal-close">‚úï</button>
            </div>
            <div class="modal-toolbar" id="modal-toolbar" style="display: none;">
                <input class="modal-search" id="modal-search" type="text" placeholder="Filter rows...">
                <span class="modal-stats" id="modal-stats"></span>
            </div>
            <div class="version-nav" id="version-nav">
                <button class="version-nav-btn" id="version-prev" title="Previous version">‚óÄ</button>
                <div class="version-info">
                    <div class="version-commit-msg" id="version-msg">Loading history‚Ä¶</div>
                    <div class="version-commit-meta" id="version-meta"></div>
                </div>
                <span class="version-counter" id="version-counter"></span>
                <button class="version-nav-btn" id="version-next" title="Next version">‚ñ∂</button>
            </div>
            <div class="modal-body" id="modal-body"></div>
        </div>
    </div>

    <script>
        (function () {
            "use strict";

            const STATE_COLORS = {
                valid: { bg: '#064e3b', border: '#10b981', text: '#ecfdf5', glow: 'rgba(16,185,129,0.5)' },
                needs_rerun: { bg: '#a16207', border: '#fde047', text: '#fefce8', glow: 'rgba(253,224,71,0.6)' },
                failed: { bg: '#450a0a', border: '#f43f5e', text: '#fff1f2', glow: 'rgba(244,63,94,0.6)' },
                never_run: { bg: '#1e293b', border: '#64748b', text: '#f1f5f9', glow: 'rgba(100,116,139,0.3)' },
                running: { bg: '#1e1b4b', border: '#818cf8', text: '#e0e7ff', glow: 'rgba(99,102,241,0.5)' },
            };

            const STATE_LABELS = {
                valid: 'Valid',
                needs_rerun: 'Needs rerun',
                failed: 'Failed',
                never_run: 'Never run',
                running: 'Running',
                frozen: 'Frozen',
            };

            let cy = null;
            let selectedStage = null;
            let _currentRunningStage = null;
            let _pipelineData = null;  // store last fetched data

            // ‚îÄ‚îÄ‚îÄ Commit Navigation State ‚îÄ‚îÄ‚îÄ
            let _commitList = [];      // [{hash, short_hash, message, author, date}, ...]
            let _commitIndex = 0;      // 0 = HEAD (most recent)
            let _isHistoryMode = false; // true when viewing a past commit


            // ‚îÄ‚îÄ‚îÄ Fetch pipeline data ‚îÄ‚îÄ‚îÄ
            async function fetchPipeline() {
                const res = await fetch('/api/pipeline');
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                return await res.json();
            }

            // ‚îÄ‚îÄ‚îÄ Build Cytoscape elements ‚îÄ‚îÄ‚îÄ
            function buildElements(data) {
                const elements = [];

                for (const node of data.nodes) {
                    const sc = STATE_COLORS[node.state] || STATE_COLORS.never_run;
                    elements.push({
                        group: 'nodes',
                        data: {
                            id: node.id,
                            label: node.id,
                            state: node.state,
                            cmd: node.cmd,
                            deps: node.deps,
                            outs: node.outs,
                            params: node.params || [],
                            metrics: node.metrics || [],
                            plots: node.plots || [],
                            hydra_config: node.hydra_config || null,
                            hydra_config_exists: node.hydra_config_exists || false,
                            frozen: node.frozen || false,
                            bgColor: sc.bg,

                            borderColor: sc.border,
                            textColor: sc.text,
                            glowColor: sc.glow,
                        },
                    });
                }

                for (const edge of data.edges) {
                    elements.push({
                        group: 'edges',
                        data: {
                            id: `${edge.source}->${edge.target}`,
                            source: edge.source,
                            target: edge.target,
                            label: edge.label || '',
                        },
                    });
                }

                return elements;
            }

            // ‚îÄ‚îÄ‚îÄ Init Cytoscape ‚îÄ‚îÄ‚îÄ
            function initGraph(elements) {
                cy = cytoscape({
                    container: document.getElementById('cy'),
                    elements: elements,
                    layout: {
                        name: 'dagre',
                        rankDir: 'TB',
                        nodeSep: 60,
                        rankSep: 80,
                        edgeSep: 30,
                        padding: 50,
                        animate: true,
                        animationDuration: 600,
                        animationEasing: 'ease-out-cubic',
                    },
                    style: [
                        {
                            selector: 'node',
                            style: {
                                'label': (ele) => ele.data('label'),
                                'width': 'label',

                                'height': 40,
                                'padding': '16px',
                                'shape': 'roundrectangle',
                                'background-color': 'data(bgColor)',
                                'border-width': 2,
                                'border-color': 'data(borderColor)',
                                'color': 'data(textColor)',
                                'font-family': "'Inter', sans-serif",
                                'font-size': 13,
                                'font-weight': 500,
                                'text-valign': 'center',
                                'text-halign': 'center',
                                'text-wrap': 'none',
                                'transition-property': 'border-width, border-color, background-color',
                                'transition-duration': '0.15s',
                            },
                        },
                        {
                            selector: 'node[?frozen]',
                            style: {
                                'background-color': '#eff6ff', // blue-50
                                'border-color': '#3b82f6', // blue-500
                                'color': '#1d4ed8', // blue-700
                                'label': (ele) => '‚ùÑÔ∏è ' + ele.data('label'),
                            }
                        },
                        {
                            selector: 'node:active, node:selected',
                            style: {
                                'border-width': 3,
                                'border-color': '#6366f1',
                                'overlay-opacity': 0,
                            },
                        },
                        {
                            selector: 'node.hover',
                            style: {
                                'border-width': 3,
                            },
                        },
                        {
                            selector: 'edge',
                            style: {
                                'width': 2,
                                'line-color': 'rgba(99, 102, 241, 0.35)',
                                'target-arrow-color': 'rgba(99, 102, 241, 0.55)',
                                'target-arrow-shape': 'triangle',
                                'arrow-scale': 1.1,
                                'curve-style': 'bezier',
                                'transition-property': 'line-color, target-arrow-color, width',
                                'transition-duration': '0.15s',
                            },
                        },
                        {
                            selector: 'edge:selected',
                            style: {
                                'width': 3,
                                'line-color': 'rgba(99, 102, 241, 0.7)',
                                'target-arrow-color': 'rgba(99, 102, 241, 0.9)',
                            },
                        },
                        {
                            selector: 'node.dimmed',
                            style: {
                                'opacity': 0.25,
                            },
                        },
                        {
                            selector: 'edge.dimmed',
                            style: {
                                'opacity': 0.12,
                            },
                        },
                        {
                            selector: 'node.highlighted',
                            style: {
                                'opacity': 1,
                            },
                        },
                        {
                            selector: 'edge.highlighted',
                            style: {
                                'opacity': 1,
                                'width': 3,
                                'line-color': 'rgba(99, 102, 241, 0.7)',
                                'target-arrow-color': 'rgba(99, 102, 241, 0.9)',
                            },
                        },
                    ],
                    minZoom: 0.2,
                    maxZoom: 3,
                    wheelSensitivity: 0.3,
                });

                // ‚îÄ‚îÄ‚îÄ Click on node ‚Üí select & show detail ‚îÄ‚îÄ‚îÄ
                cy.on('tap', 'node', function (evt) {
                    const node = evt.target;
                    selectedStage = node.data().id;
                    showDetail(node.data());
                    highlightNeighborhood(node);
                    removeNodeBadge(node.data().id);
                });

                // Reposition floating badges on pan/zoom
                cy.on('render', repositionNodeBadges);

                // ‚îÄ‚îÄ‚îÄ Click on background ‚Üí deselect ‚îÄ‚îÄ‚îÄ
                cy.on('tap', function (evt) {
                    if (evt.target === cy) {
                        selectedStage = null;
                        clearDetail();
                        clearHighlight();
                    }
                });

                // ‚îÄ‚îÄ‚îÄ Hover tooltip ‚îÄ‚îÄ‚îÄ
                const tooltip = document.getElementById('tooltip');
                cy.on('mouseover', 'node', function (evt) {
                    const node = evt.target;
                    node.addClass('hover');
                    const pos = node.renderedPosition();
                    const container = document.getElementById('cy').getBoundingClientRect();
                    tooltip.textContent = `${node.data('label')} ‚Äî ${STATE_LABELS[node.data('state')]}`;
                    tooltip.style.left = (pos.x) + 'px';
                    tooltip.style.top = (pos.y) + 'px';
                    tooltip.classList.add('visible');
                });

                cy.on('mouseout', 'node', function (evt) {
                    evt.target.removeClass('hover');
                    tooltip.classList.remove('visible');
                });

                // ‚îÄ‚îÄ‚îÄ Controls ‚îÄ‚îÄ‚îÄ
                document.getElementById('btn-fit').addEventListener('click', () => {
                    cy.fit(undefined, 50);
                });
                document.getElementById('btn-zoom-in').addEventListener('click', () => {
                    cy.zoom({ level: cy.zoom() * 1.3, renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 } });
                });
                document.getElementById('btn-zoom-out').addEventListener('click', () => {
                    cy.zoom({ level: cy.zoom() / 1.3, renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 } });
                });

                return cy;
            }

            // ‚îÄ‚îÄ‚îÄ Highlight execution chain (all upstream ancestors + the node) ‚îÄ‚îÄ‚îÄ
            function highlightNeighborhood(node) {
                // Clear any previous highlighting first
                cy.elements().removeClass('dimmed highlighted');
                cy.elements().addClass('dimmed');
                // BFS upstream: find all predecessors (stages that would run before this one)
                const chain = cy.collection().merge(node);
                const queue = [node];
                const visited = new Set([node.id()]);
                while (queue.length > 0) {
                    const current = queue.shift();
                    const preds = current.predecessors('node');
                    preds.forEach(pred => {
                        if (!visited.has(pred.id())) {
                            visited.add(pred.id());
                            chain.merge(pred);
                            queue.push(pred);
                        }
                    });
                }
                // Also include edges between chain nodes
                const chainEdges = chain.edgesWith(chain);
                chain.merge(chainEdges);
                chain.removeClass('dimmed').addClass('highlighted');
            }

            function clearHighlight() {
                cy.elements().removeClass('dimmed highlighted');
            }

            // ‚îÄ‚îÄ‚îÄ Sidebar detail ‚îÄ‚îÄ‚îÄ
            function showDetail(data) {
                document.getElementById('sidebar-empty').style.display = 'none';
                const detail = document.getElementById('sidebar-detail');
                detail.style.display = 'block';

                document.getElementById('detail-name').textContent = data.id;

                const badge = document.getElementById('detail-badge');
                const isFrozen = data.frozen;
                badge.textContent = isFrozen ? 'Frozen' : STATE_LABELS[data.state];
                badge.className = 'state-badge ' + (isFrozen ? 'frozen' : data.state);

                document.getElementById('detail-cmd').textContent = data.cmd || '(no command)';

                const sections = document.getElementById('detail-sections');
                sections.innerHTML = '';

                // File items are now objects: {path, exists, status}
                const addFileSection = (title, items, cls = '', clickable = false) => {
                    if (!items || items.length === 0) return;
                    const sec = document.createElement('div');
                    sec.className = 'sidebar-section';
                    sec.innerHTML = `<div class="section-title">${title}</div>`;
                    const ul = document.createElement('ul');
                    ul.className = 'file-list';
                    for (const item of items) {
                        const path = typeof item === 'string' ? item : item.path;
                        const status = typeof item === 'string' ? 'unknown' : (item.status || 'unknown');
                        const canInspect = clickable && isInspectable(path);
                        const isNew = _updatedOutputs.has(path);
                        const li = document.createElement('li');
                        li.className = 'file-item' + (cls ? ' ' + cls : '') + ` status-${status}` + (canInspect ? ' inspectable' : '') + (canInspect && isNew ? ' has-update' : '');
                        const dot = document.createElement('span');
                        dot.className = `status-dot ${status}`;
                        li.appendChild(dot);
                        li.appendChild(document.createTextNode(path));
                        if (canInspect) {
                            li.addEventListener('click', (e) => {
                                e.stopPropagation();
                                _updatedOutputs.delete(path);
                                li.classList.remove('has-update');
                                openFileInspector(path);
                            });
                        }
                        ul.appendChild(li);
                    }
                    sec.appendChild(ul);
                    sections.appendChild(sec);
                };

                // Params remain plain strings
                const addSection = (title, items, cls = '') => {
                    if (!items || items.length === 0) return;
                    const sec = document.createElement('div');
                    sec.className = 'sidebar-section';
                    sec.innerHTML = `<div class="section-title">${title}</div>`;
                    const ul = document.createElement('ul');
                    ul.className = 'file-list';
                    for (const item of items) {
                        const li = document.createElement('li');
                        li.className = 'file-item' + (cls ? ' ' + cls : '');
                        li.textContent = item;
                        ul.appendChild(li);
                    }
                    sec.appendChild(ul);
                    sections.appendChild(sec);
                };

                addFileSection('Dependencies', data.deps, '', false);
                addFileSection('Outputs', data.outs, '', true);
                addSection('Parameters', data.params, 'param');
                addFileSection('Metrics', data.metrics, 'metric', true);
                addFileSection('Plots', data.plots, 'plot', true);

                // ‚îÄ‚îÄ‚îÄ Hydra Config Accordion ‚îÄ‚îÄ‚îÄ
                if (data.hydra_config) {
                    const acc = document.createElement('div');
                    acc.className = 'accordion sidebar-section';
                    acc.style.padding = '0';
                    acc.style.borderBottom = '1px solid var(--border)';

                    const header = document.createElement('div');
                    header.className = 'accordion-header';
                    header.innerHTML = `
                        <div class="accordion-header-left">
                            <span class="section-title">‚öôÔ∏è Hydra Config</span>
                        </div>
                        <span class="accordion-chevron">‚ñ∂</span>
                    `;

                    const body = document.createElement('div');
                    body.className = 'accordion-body';

                    const content = document.createElement('div');
                    content.className = 'accordion-content';
                    content.innerHTML = `<div class="hydra-loading"><div class="mini-spinner"></div>Loading config‚Ä¶</div>`;
                    body.appendChild(content);

                    let loaded = false;

                    header.addEventListener('click', () => {
                        acc.classList.toggle('open');
                        if (!loaded && acc.classList.contains('open')) {
                            loaded = true;
                            loadHydraParams(data.hydra_config, content);
                        }
                    });

                    async function loadHydraParams(configPath, container) {
                        try {
                            const res = await fetch(`/api/hydra-config?path=${encodeURIComponent(configPath)}`);
                            const result = await res.json();
                            if (result.error) {
                                container.innerHTML = `<div class="hydra-loading" style="color:#ef4444;">‚ùå ${escapeHtml(result.error)}</div>`;
                                return;
                            }

                            const params = result.params || [];
                            const sources = result.sources || [configPath];

                            // Store original values + source for diff
                            const originals = {};   // key ‚Üí value
                            const paramSources = {}; // key ‚Üí source path
                            params.forEach(p => {
                                originals[p.key] = p.value;
                                paramSources[p.key] = p.source || configPath;
                            });

                            container.innerHTML = '';

                            // Input registry for collecting values on save
                            const inputRegistry = {}; // key ‚Üí {getValue(), source}

                            function renderParam(param, parentEl) {
                                const row = document.createElement('div');
                                row.className = 'hydra-param';

                                const keyLabel = document.createElement('span');
                                keyLabel.className = 'hydra-param-key';
                                keyLabel.textContent = param.shortKey;
                                keyLabel.title = param.key;
                                row.appendChild(keyLabel);

                                if (param.type === 'bool') {
                                    const toggle = document.createElement('label');
                                    toggle.className = 'hydra-toggle';
                                    const cb = document.createElement('input');
                                    cb.type = 'checkbox';
                                    cb.checked = !!param.value;
                                    const track = document.createElement('span');
                                    track.className = 'hydra-toggle-track';
                                    const thumb = document.createElement('span');
                                    thumb.className = 'hydra-toggle-thumb';
                                    toggle.appendChild(cb);
                                    toggle.appendChild(track);
                                    toggle.appendChild(thumb);
                                    row.appendChild(toggle);
                                    cb.addEventListener('change', checkChanges);
                                    inputRegistry[param.key] = { getValue: () => cb.checked, source: param.source || configPath };
                                } else if (param.type === 'list') {
                                    const listSpan = document.createElement('span');
                                    listSpan.className = 'hydra-list-value';
                                    listSpan.textContent = JSON.stringify(param.value);
                                    listSpan.title = 'Lists cannot be edited inline';
                                    row.appendChild(listSpan);
                                } else if (param.type === 'null') {
                                    const nullSpan = document.createElement('span');
                                    nullSpan.className = 'hydra-null-value';
                                    nullSpan.textContent = 'null';
                                    row.appendChild(nullSpan);
                                } else {
                                    const input = document.createElement('input');
                                    input.className = 'hydra-param-input';
                                    input.type = (param.type === 'int' || param.type === 'float') ? 'number' : 'text';
                                    if (param.type === 'float') input.step = 'any';
                                    input.value = param.value ?? '';
                                    input.addEventListener('input', () => {
                                        const orig = String(originals[param.key] ?? '');
                                        input.classList.toggle('modified', input.value !== orig);
                                        checkChanges();
                                    });
                                    row.appendChild(input);
                                    inputRegistry[param.key] = { getValue: () => input.value, source: param.source || configPath };
                                }

                                const typeBadge = document.createElement('span');
                                typeBadge.className = 'hydra-param-type';
                                typeBadge.textContent = param.type;
                                row.appendChild(typeBadge);

                                parentEl.appendChild(row);
                            }

                            // Group params by source file, then by top-level key within each source
                            for (const sourcePath of sources) {
                                const sourceParams = params.filter(p => (p.source || configPath) === sourcePath);
                                if (sourceParams.length === 0) continue;

                                // Source file header
                                const sourceDiv = document.createElement('div');
                                sourceDiv.style.marginBottom = '8px';
                                const sourceHeader = document.createElement('div');
                                sourceHeader.className = 'hydra-config-path';
                                const basename = sourcePath.split('/').pop();
                                sourceHeader.innerHTML = `üìÅ <span class="path-text" title="${escapeHtml(sourcePath)}">${escapeHtml(basename)}</span>`;
                                sourceDiv.appendChild(sourceHeader);

                                // Group by top-level key within this source
                                const groups = {};
                                const topLevel = [];
                                sourceParams.forEach(p => {
                                    const dotIdx = p.key.indexOf('.');
                                    if (dotIdx > -1) {
                                        const group = p.key.substring(0, dotIdx);
                                        if (!groups[group]) groups[group] = [];
                                        groups[group].push({ ...p, shortKey: p.key.substring(dotIdx + 1) });
                                    } else {
                                        topLevel.push({ ...p, shortKey: p.key });
                                    }
                                });

                                topLevel.forEach(p => renderParam(p, sourceDiv));
                                for (const [groupName, groupParams] of Object.entries(groups)) {
                                    const groupDiv = document.createElement('div');
                                    groupDiv.className = 'hydra-group';
                                    const groupHeader = document.createElement('div');
                                    groupHeader.className = 'hydra-group-header';
                                    groupHeader.textContent = groupName;
                                    groupDiv.appendChild(groupHeader);
                                    groupParams.forEach(p => renderParam(p, groupDiv));
                                    sourceDiv.appendChild(groupDiv);
                                }

                                container.appendChild(sourceDiv);
                            }

                            // Actions bar
                            const actions = document.createElement('div');
                            actions.className = 'hydra-actions';

                            const status = document.createElement('span');
                            status.className = 'hydra-status';

                            const saveBtn = document.createElement('button');
                            saveBtn.className = 'hydra-save-btn';
                            saveBtn.innerHTML = 'üíæ Save';
                            saveBtn.disabled = true;

                            actions.appendChild(status);
                            actions.appendChild(saveBtn);
                            container.appendChild(actions);

                            function checkChanges() {
                                let hasChanges = false;
                                for (const [key, reg] of Object.entries(inputRegistry)) {
                                    const current = reg.getValue();
                                    const orig = originals[key];
                                    if (String(current) !== String(orig ?? '')) {
                                        hasChanges = true;
                                        break;
                                    }
                                }
                                saveBtn.disabled = !hasChanges;
                                if (hasChanges) {
                                    status.className = 'hydra-status unsaved';
                                    status.textContent = '‚óè Unsaved changes';
                                } else {
                                    status.className = 'hydra-status';
                                    status.textContent = '';
                                }
                            }

                            saveBtn.addEventListener('click', async () => {
                                // Collect only changed params with their source
                                const changedParams = {};
                                for (const [key, reg] of Object.entries(inputRegistry)) {
                                    const current = reg.getValue();
                                    const orig = originals[key];
                                    if (String(current) !== String(orig ?? '')) {
                                        changedParams[key] = { value: current, source: reg.source };
                                    }
                                }
                                if (Object.keys(changedParams).length === 0) return;

                                saveBtn.disabled = true;
                                saveBtn.innerHTML = '‚è≥ Saving‚Ä¶';
                                status.className = 'hydra-status';
                                status.textContent = '';

                                try {
                                    const putRes = await fetch('/api/hydra-config', {
                                        method: 'PUT',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ path: configPath, params: changedParams }),
                                    });
                                    const putData = await putRes.json();

                                    if (putData.success) {
                                        for (const [key, val] of Object.entries(changedParams)) {
                                            originals[key] = val.value;
                                        }
                                        container.querySelectorAll('.hydra-param-input.modified').forEach(el => el.classList.remove('modified'));
                                        saveBtn.innerHTML = '‚úÖ Saved!';
                                        saveBtn.classList.add('saved');
                                        status.className = 'hydra-status';
                                        status.textContent = '';
                                        setTimeout(() => {
                                            saveBtn.innerHTML = 'üíæ Save';
                                            saveBtn.classList.remove('saved');
                                            saveBtn.disabled = true;
                                        }, 2000);
                                    } else {
                                        saveBtn.innerHTML = 'üíæ Save';
                                        saveBtn.disabled = false;
                                        status.className = 'hydra-status error';
                                        status.textContent = putData.error || 'Save failed';
                                    }
                                } catch (err) {
                                    saveBtn.innerHTML = 'üíæ Save';
                                    saveBtn.disabled = false;
                                    status.className = 'hydra-status error';
                                    status.textContent = 'Network error';
                                }
                            });

                        } catch (err) {
                            container.innerHTML = `<div class="hydra-loading" style="color:#ef4444;">‚ùå Failed to load config</div>`;
                        }
                    }

                    acc.appendChild(header);
                    acc.appendChild(body);
                    sections.appendChild(acc);
                }

                // ‚îÄ‚îÄ‚îÄ Execution Logs section ‚îÄ‚îÄ‚îÄ
                const stageId = data.id;
                const logs = stageLogs[stageId];
                const timer = _stageTimers[stageId];
                const durationStr = timer && timer.duration ? ` ¬∑ ${formatElapsed(timer.duration)}` : '';
                const logsDiv = document.createElement('div');
                logsDiv.className = 'sidebar-logs';
                if (logs && logs.trim()) {
                    logsDiv.innerHTML = `
                        <div class="sidebar-logs-header">
                            <span class="sidebar-logs-title">Execution Logs<span class="sidebar-logs-duration">${durationStr}</span></span>
                            <button class="sidebar-logs-copy" data-stage="${stageId}">üìã Copy</button>
                        </div>
                        <pre class="sidebar-logs-content">${escapeHtml(logs)}</pre>
                    `;
                    logsDiv.querySelector('.sidebar-logs-copy').addEventListener('click', () => {
                        navigator.clipboard.writeText(stageLogs[stageId] || '').then(() => {
                            const btn = logsDiv.querySelector('.sidebar-logs-copy');
                            btn.textContent = '‚úÖ Copied!';
                            setTimeout(() => btn.textContent = 'üìã Copy', 2000);
                        });
                    });
                } else {
                    logsDiv.innerHTML = `
                        <div class="sidebar-logs-header">
                            <span class="sidebar-logs-title">Execution Logs</span>
                        </div>
                        <div class="sidebar-logs-empty">No execution logs yet</div>
                    `;
                }
                // Append logs below the Run Stage button
                const logsContainer = document.getElementById('sidebar-logs-container');
                logsContainer.innerHTML = '';
                logsContainer.appendChild(logsDiv);

                // Setup Freeze Button
                const btnFreeze = document.getElementById('btn-freeze-stage');
                btnFreeze.querySelector('.freeze-text').textContent = isFrozen ? 'Unfreeze' : 'Freeze';

                // Check if any ancestor is frozen
                let ancestorFrozen = false;
                if (cy) {
                    const node = cy.getElementById(data.id);
                    if (node.length) {
                        const ancestors = node.predecessors('node');
                        ancestorFrozen = ancestors.some(n => n.data('frozen'));
                    }
                }

                if (isFrozen && ancestorFrozen) {
                    btnFreeze.disabled = true;
                    btnFreeze.title = "Cannot unfreeze: parent stage is frozen";
                    btnFreeze.style.opacity = "0.5";
                    btnFreeze.style.background = 'rgba(96, 165, 250, 0.25)';
                    btnFreeze.style.cursor = 'not-allowed';
                } else {
                    btnFreeze.disabled = false;
                    btnFreeze.title = isFrozen ? "Unfreeze this stage and descendants" : "Freeze this stage and descendants";
                    btnFreeze.style.opacity = "1";
                    btnFreeze.style.background = isFrozen ? 'rgba(96, 165, 250, 0.25)' : 'rgba(96, 165, 250, 0.1)';
                    btnFreeze.style.cursor = 'pointer';
                }

                // Remove old listeners to avoid duplicates (naive approach)
                const newBtn = btnFreeze.cloneNode(true);
                btnFreeze.parentNode.replaceChild(newBtn, btnFreeze);

                newBtn.addEventListener('click', async () => {
                    if (newBtn.disabled) return;
                    newBtn.disabled = true;
                    const originalText = newBtn.querySelector('.freeze-text').textContent;
                    newBtn.querySelector('.freeze-text').textContent = 'Updating...';

                    try {
                        const res = await fetch('/api/stage/freeze', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ stage: data.id, frozen: !isFrozen }),
                        });
                        const resData = await res.json();

                        if (resData.error) {
                            alert('Error: ' + resData.error);
                            // Revert text on error
                            newBtn.querySelector('.freeze-text').textContent = originalText;
                        } else {
                            // Success - we expect pollPipeline to refresh everything eventually
                            // But let's show success state immediately or just re-enable
                            showToast(`Stage ${data.id} ${!isFrozen ? 'frozen' : 'unfrozen'}`, 'success');

                            // Immediately force a poll to update UI
                            pollPipeline();
                        }
                    } catch (err) {
                        alert('Network error: ' + err);
                        newBtn.querySelector('.freeze-text').textContent = originalText;
                    } finally {
                        newBtn.disabled = false;
                        // We rely on polling to update the button text to the new state
                        // If polling is slow, user sees "Updating..." which is fine, but if it fails silently...
                        // Let's reset to "processed" state locally for better UX?
                        if (!newBtn.disabled) {
                            // If we are here, fetch completed.
                            // If success, the state should flip.
                            // But since we rely on `showDetail` re-rendering with new data...
                        }
                    }
                });

            }


            function clearDetail() {
                document.getElementById('sidebar-empty').style.display = 'flex';
                document.getElementById('sidebar-detail').style.display = 'none';
                if (_pipelineData) renderNodeList(_pipelineData);
            }

            function renderNodeList(data) {
                const list = document.getElementById('sidebar-node-list');
                const scrollPos = list.scrollTop;
                list.innerHTML = '';

                const filter = (document.getElementById('sidebar-search')?.value || '').toLowerCase();

                const order = data.execution_order || data.nodes.map(n => n.id);

                // Identify the "next up" stage: the first non-valid stage in topological order
                let nextUpId = data.is_running ? data.running_stage : null;
                if (!nextUpId) {
                    for (const nodeName of order) {
                        const node = data.nodes.find(n => n.id === nodeName);
                        if (node && node.state !== 'valid' && node.state !== 'running' && !node.frozen) {
                            nextUpId = nodeName;
                            break;
                        }
                    }
                }
                for (const nodeName of order) {
                    const node = data.nodes.find(n => n.id === nodeName);
                    if (!node) continue;

                    // Search filter
                    if (filter && !nodeName.toLowerCase().includes(filter)) continue;

                    // Status filter
                    const stateFilter = document.getElementById('sidebar-status-filter')?.value || 'all';
                    if (stateFilter !== 'all') {
                        if (stateFilter === 'frozen' && !node.frozen) continue;
                        if (stateFilter !== 'frozen' && node.state !== stateFilter) continue;
                    }

                    const li = document.createElement('li');
                    const isNext = nodeName === nextUpId;
                    const isFrozen = node.frozen;
                    li.className = 'sidebar-node-item' + (isNext ? ' next-up' : '') + (isFrozen ? ' frozen' : '');

                    let prefix = '';
                    if (isFrozen) prefix = '<span style="margin-right:4px">‚ùÑÔ∏è</span>';
                    else if (isNext) prefix = (data.is_running && nodeName === data.running_stage ? '<span style="margin-right:4px">‚ö°</span>' : '<span style="margin-right:4px">‚è≥</span>');

                    li.innerHTML = `
                        <span class="node-name">${prefix}${nodeName}</span>
                        <span class="node-status-badge ${isFrozen ? 'frozen' : node.state}">${isFrozen ? 'Frozen' : STATE_LABELS[node.state]}</span>
                    `;
                    li.addEventListener('click', () => {
                        const cyNode = cy.getElementById(nodeName);
                        if (cyNode.length) {
                            selectedStage = nodeName;
                            showDetail(cyNode.data());
                            highlightNeighborhood(cyNode);
                            removeNodeBadge(nodeName);

                            // Center and zoom
                            cy.animate({
                                center: { eles: cyNode },
                                zoom: 1.5,
                                duration: 500,
                                easing: 'ease-out-cubic'
                            });
                        }
                    });
                    list.appendChild(li);
                }
                list.scrollTop = scrollPos;
            }

            // ‚îÄ‚îÄ‚îÄ Stats bar ‚îÄ‚îÄ‚îÄ
            function updateStats(data) {
                const counts = { valid: 0, needs_rerun: 0, never_run: 0, running: 0 };
                for (const n of data.nodes) counts[n.state] = (counts[n.state] || 0) + 1;

                const bar = document.getElementById('stats-bar');
                let html = `
            <div class="stat-chip"><span class="count">${data.nodes.length}</span> stages</div>
            <div class="stat-chip"><span class="count">${data.edges.length}</span> edges</div>
            <div class="stat-chip"><span class="count" style="color: var(--state-valid)">${counts.valid}</span> valid</div>
            <div class="stat-chip"><span class="count" style="color: var(--state-rerun)">${counts.needs_rerun}</span> needs rerun</div>
            <div class="stat-chip"><span class="count" style="color: var(--state-never)">${counts.never_run}</span> never run</div>`;
                if (counts.running > 0) {
                    html += `\n            <div class="stat-chip"><span class="count" style="color: #818cf8">${counts.running}</span> running</div>`;
                }
                bar.innerHTML = html;
            }

            // ‚îÄ‚îÄ‚îÄ Unified Pipeline Polling (data-driven) ‚îÄ‚îÄ‚îÄ
            let _prevIsRunning = false;
            let _prevRunningStage = null;
            let _pollTimer = null;
            let _uiLaunchedRun = false;  // true when run was launched from UI

            function startPolling() {
                if (_pollTimer) return;
                _pollTimer = setInterval(pollPipeline, 1_000);
            }

            function stopPolling() {
                if (_pollTimer) {
                    clearInterval(_pollTimer);
                    _pollTimer = null;
                }
            }

            async function pollPipeline() {
                if (_isHistoryMode) return; // Skip polling in history mode
                try {
                    const data = await fetchPipeline();
                    if (data.error) return;
                    _pipelineData = data;

                    const nowRunning = data.is_running || false;
                    const nowStage = data.running_stage || null;

                    // Detect structural changes (nodes/edges actually added or removed)
                    // Compare by IDs, not counts, to avoid false positives from
                    // duplicate edge IDs (same source->target with different labels)
                    let structureChanged = false;
                    if (!cy || cy.nodes().length === 0) {
                        structureChanged = true;
                    } else {
                        const cyNodeIds = new Set(cy.nodes().map(n => n.id()));
                        const apiNodeIds = new Set(data.nodes.map(n => n.id));
                        if (cyNodeIds.size !== apiNodeIds.size ||
                            [...apiNodeIds].some(id => !cyNodeIds.has(id))) {
                            structureChanged = true;
                        }
                    }
                    if (structureChanged) {
                        const elements = buildElements(data);
                        if (cy) cy.destroy();
                        initGraph(elements);
                        updateStats(data);
                        return;
                    }

                    // ‚îÄ‚îÄ Run state transitions ‚îÄ‚îÄ
                    const allBtn = document.getElementById('btn-run-all');
                    const stageBtn = document.getElementById('btn-run-stage');
                    const stopBtn = document.getElementById('btn-stop');

                    // Transition: not running ‚Üí running (external run detected)
                    if (nowRunning && !_prevIsRunning && !_uiLaunchedRun) {
                        isRunning = true;
                        allBtn.classList.add('running');
                        allBtn.disabled = true;
                        stageBtn.disabled = true;
                        stopBtn.classList.add('visible');
                        showToast(nowStage ? `Running: ${nowStage}` : 'Pipeline running‚Ä¶', 'running');
                    }

                    // Stage changed during run
                    if (nowRunning && nowStage !== _prevRunningStage) {
                        console.log('[POLL] Stage transition:', _prevRunningStage, '->', nowStage);
                        // Stop animation on previous stage
                        if (_prevRunningStage) {
                            stopSingleNodeAnimation(_prevRunningStage, true);
                        }
                        if (cy) cy.nodes().forEach(n => {
                            if (n.id() !== nowStage && n.scratch('_animating')) {
                                stopSingleNodeAnimation(n.id());
                            }
                        });
                        // Start animation on new stage
                        if (nowStage) {
                            startSingleNodeAnimation(nowStage);
                            showToast(`Running: ${nowStage}`, 'running');
                        }
                    }

                    // Transition: running ‚Üí not running
                    if (!nowRunning && _prevIsRunning) {
                        isRunning = false;
                        allBtn.classList.remove('running');
                        allBtn.disabled = false;
                        stageBtn.disabled = false;
                        stopBtn.classList.remove('visible');
                        // Stop all animations
                        if (cy) cy.nodes().forEach(n => {
                            if (n.scratch('_animating')) {
                                stopSingleNodeAnimation(n.id());
                            }
                        });
                        if (!_uiLaunchedRun) {
                            // External run finished
                            showToast('Pipeline completed', 'success');
                            setTimeout(hideToast, 4000);
                        }
                        _uiLaunchedRun = false;
                    }

                    _prevIsRunning = nowRunning;
                    _prevRunningStage = nowStage;

                    // ‚îÄ‚îÄ Update node states/colors only when changed ‚îÄ‚îÄ
                    for (const node of data.nodes) {
                        const cyNode = cy.getElementById(node.id);
                        if (!cyNode.length) continue;

                        // Always keep metadata in sync
                        const prevState = cyNode.data('state');
                        cyNode.data({
                            deps: node.deps,
                            outs: node.outs,
                            metrics: node.metrics,
                            plots: node.plots,
                            frozen: node.frozen || false,
                            hydra_config: node.hydra_config || null,
                            hydra_config_exists: node.hydra_config_exists || false,
                        });

                        // Sidebar state badge is updated in-place below (line ~2565)
                        // to preserve open accordions and scroll position.


                        // Skip color update for nodes with active animation
                        if (cyNode.scratch('_animating')) {
                            cyNode.data('state', node.state);
                            continue;
                        }

                        // Only update visual styles if state actually changed
                        if (prevState !== node.state) {
                            const sc = STATE_COLORS[node.state] || STATE_COLORS.never_run;
                            cyNode.removeStyle();
                            cyNode.data({
                                state: node.state,
                                bgColor: sc.bg,
                                borderColor: sc.border,
                                textColor: sc.text,
                                glowColor: sc.glow,
                            });
                        }
                    }

                    updateStats(data);

                    // Update sidebar metadata in-place (without rebuilding DOM)
                    // This preserves open accordions (Hydra config) and scroll position
                    if (selectedStage) {
                        const updatedNode = data.nodes.find(n => n.id === selectedStage);
                        if (updatedNode) {
                            const badge = document.getElementById('detail-badge');
                            if (badge) {
                                badge.textContent = STATE_LABELS[updatedNode.state];
                                badge.className = 'state-badge ' + updatedNode.state;
                            }
                        }
                    } else {
                        // Update node list if no stage selected
                        renderNodeList(data);
                    }
                } catch (err) {
                    // Silently ignore poll errors
                }
            }


            // ‚îÄ‚îÄ‚îÄ Boot ‚îÄ‚îÄ‚îÄ
            async function boot() {
                const loading = document.getElementById('loading');
                try {
                    const data = await fetchPipeline();
                    if (data.error) throw new Error(data.error);

                    const elements = buildElements(data);
                    _pipelineData = data;
                    initGraph(elements);
                    updateStats(data);
                    renderNodeList(data);

                    // Handle case where a run is already in progress at boot
                    if (data.is_running && data.running_stage) {
                        isRunning = true;
                        document.getElementById('btn-run-all').classList.add('running');
                        document.getElementById('btn-run-all').disabled = true;
                        document.getElementById('btn-run-stage').disabled = true;
                        document.getElementById('btn-stop').classList.add('visible');
                        startSingleNodeAnimation(data.running_stage);
                        showToast(`Running: ${data.running_stage}`, 'running');
                        _prevIsRunning = true;
                        _prevRunningStage = data.running_stage;
                    }

                    startPolling();

                    // Load commit list for navigation
                    try {
                        const cRes = await fetch('/api/commits?limit=100');
                        const cData = await cRes.json();
                        _commitList = cData.commits || [];
                        if (_commitList.length > 0) {
                            _commitIndex = 0;
                            updateCommitNav();
                            document.getElementById('commit-nav').style.display = 'flex';
                        }
                    } catch (e) {
                        console.warn('Could not load commit list:', e);
                    }

                    setTimeout(() => loading.classList.add('hidden'), 400);
                } catch (err) {
                    console.error('[BOOT ERROR]', err.message, err.stack);
                    loading.innerHTML = `
                <div class="error-container">
                    <div class="error-icon">üí•</div>
                    <div class="error-title">Failed to load pipeline</div>
                    <div class="error-message">${err.message}</div>
                </div>
            `;
                }
            }

            // ‚îÄ‚îÄ‚îÄ File Inspector ‚îÄ‚îÄ‚îÄ
            const FILE_ICONS = {
                csv: 'üìä', image: 'üñºÔ∏è', pdf: 'üìï', text: 'üìÑ', binary: 'üì¶',
            };

            // ‚îÄ‚îÄ‚îÄ Version History State ‚îÄ‚îÄ‚îÄ
            let _versionHistory = [];    // Array of {hash, message, author, date}
            let _versionIndex = -1;      // -1 = current (working tree), 0 = most recent commit, etc.
            let _currentFilePath = null;
            let _currentFileType = null;

            async function loadFileHistory(filePath) {
                try {
                    const res = await fetch(`/api/file/history?path=${encodeURIComponent(filePath)}`);
                    const data = await res.json();
                    _versionHistory = data.commits || [];
                } catch {
                    _versionHistory = [];
                }
            }

            function updateVersionNav() {
                const nav = document.getElementById('version-nav');
                const prevBtn = document.getElementById('version-prev');
                const nextBtn = document.getElementById('version-next');
                const msg = document.getElementById('version-msg');
                const meta = document.getElementById('version-meta');
                const counter = document.getElementById('version-counter');

                if (_versionHistory.length === 0) {
                    nav.classList.remove('active');
                    return;
                }

                nav.classList.add('active');

                if (_versionIndex === -1) {
                    msg.innerHTML = '<span class="version-current-badge">CURRENT</span> Working tree';
                    meta.textContent = 'Live file on disk';
                } else {
                    const commit = _versionHistory[_versionIndex];
                    msg.textContent = commit.message;
                    const shortHash = commit.hash.substring(0, 8);
                    const dateStr = commit.date.split(' ').slice(0, 2).join(' ');
                    meta.textContent = `${shortHash} ¬∑ ${commit.author} ¬∑ ${dateStr}`;
                }

                const total = _versionHistory.length + 1; // +1 for current
                const pos = _versionIndex + 2; // 1-based, current=1
                counter.textContent = `${pos}/${total}`;

                // Prev = go to older version (higher index)
                prevBtn.disabled = (_versionIndex >= _versionHistory.length - 1);
                // Next = go to newer version (lower index, or back to current)
                nextBtn.disabled = (_versionIndex === -1);
            }

            async function navigateVersion(direction) {
                // direction: -1 = newer (toward current), +1 = older
                const newIndex = _versionIndex + direction;
                if (newIndex < -1 || newIndex >= _versionHistory.length) return;

                _versionIndex = newIndex;
                updateVersionNav();
                await loadVersionContent();
            }

            async function loadVersionContent() {
                const body = document.getElementById('modal-body');
                body.innerHTML = '<div class="loading-overlay" style="position:relative;min-height:200px;"><div class="loading-spinner"></div></div>';

                const filePath = _currentFilePath;
                const fileType = _currentFileType;

                try {
                    if (_versionIndex === -1) {
                        // Load current version (from disk)
                        switch (fileType) {
                            case 'csv': await renderCSV(filePath); break;
                            case 'image': renderImage(filePath); break;
                            case 'pdf': renderPDF(filePath); break;
                            case 'text': await renderText(filePath); break;
                            default: body.innerHTML = '<div class="file-not-found"><div class="file-not-found-icon">üì¶</div><div class="file-not-found-text">Binary file</div></div>';
                        }
                        return;
                    }

                    const commit = _versionHistory[_versionIndex].hash;

                    if (fileType === 'csv') {
                        const res = await fetch(`/api/file/at-commit?path=${encodeURIComponent(filePath)}&commit=${commit}`);
                        const data = await res.json();
                        if (data.error) { body.innerHTML = `<div class="file-not-found"><div class="file-not-found-icon">üï∞Ô∏è</div><div class="file-not-found-text">${data.error}</div></div>`; return; }
                        // Render CSV from historical data
                        _csvData = data;
                        _csvSortCol = null; _csvSortAsc = true;
                        const toolbar = document.getElementById('modal-toolbar');
                        const search = document.getElementById('modal-search');
                        const stats = document.getElementById('modal-stats');
                        toolbar.style.display = 'flex';
                        search.value = '';
                        stats.textContent = `${data.total} rows ¬∑ ${data.columns.length} cols`;
                        renderCSVTable('');
                    } else if (fileType === 'image') {
                        body.innerHTML = `<div class="image-viewer"><img src="/api/file/at-commit?path=${encodeURIComponent(filePath)}&commit=${commit}" alt="${filePath}"></div>`;
                    } else if (fileType === 'text') {
                        const res = await fetch(`/api/file/at-commit?path=${encodeURIComponent(filePath)}&commit=${commit}`);
                        const data = await res.json();
                        if (data.error) { body.innerHTML = `<div class="file-not-found"><div class="file-not-found-icon">üï∞Ô∏è</div><div class="file-not-found-text">${data.error}</div></div>`; return; }
                        if (filePath.endsWith('.json')) {
                            try {
                                const parsed = JSON.parse(data.content);
                                body.innerHTML = `<div class="text-viewer">${JSON.stringify(parsed, null, 2)}</div>`;
                            } catch { body.innerHTML = `<div class="text-viewer">${escapeHtml(data.content)}</div>`; }
                        } else {
                            body.innerHTML = `<div class="text-viewer">${escapeHtml(data.content)}</div>`;
                        }
                    } else if (fileType === 'pdf') {
                        body.innerHTML = `<div class="pdf-viewer"><iframe src="/api/file/at-commit?path=${encodeURIComponent(filePath)}&commit=${commit}"></iframe></div>`;
                    } else {
                        body.innerHTML = '<div class="file-not-found"><div class="file-not-found-icon">üì¶</div><div class="file-not-found-text">Preview not available for this version</div></div>';
                    }
                } catch (err) {
                    body.innerHTML = `<div class="file-not-found"><div class="file-not-found-icon">üí•</div><div class="file-not-found-text">Error: ${err.message}</div></div>`;
                }
            }

            // Version nav button events
            document.getElementById('version-prev').addEventListener('click', () => navigateVersion(1));
            document.getElementById('version-next').addEventListener('click', () => navigateVersion(-1));

            async function openFileInspector(filePath) {
                const overlay = document.getElementById('modal-overlay');
                const body = document.getElementById('modal-body');
                const toolbar = document.getElementById('modal-toolbar');
                const search = document.getElementById('modal-search');

                // Reset
                body.innerHTML = '<div class="loading-overlay" style="position:relative;min-height:200px;"><div class="loading-spinner"></div></div>';
                toolbar.style.display = 'none';
                search.value = '';
                overlay.classList.add('visible');

                // Reset version state
                _currentFilePath = filePath;
                _versionHistory = [];
                _versionIndex = -1;
                _currentFileType = null;
                document.getElementById('version-nav').classList.remove('active');

                // Load file info and history in parallel
                try {
                    // In history mode, use the commit hash for file loading
                    const _historyCommit = _isHistoryMode ? _commitList[_commitIndex]?.hash : null;

                    const [infoRes, _] = await Promise.all([
                        fetch(`/api/file/info?path=${encodeURIComponent(filePath)}`),
                        loadFileHistory(filePath),
                    ]);
                    const info = await infoRes.json();

                    document.getElementById('modal-filename').textContent = info.name || filePath;
                    document.getElementById('modal-badge').textContent = (info.extension || '').replace('.', '').toUpperCase();
                    document.getElementById('modal-icon').textContent = FILE_ICONS[info.type] || 'üìÑ';
                    _currentFileType = info.type;

                    // Show version nav if history exists
                    updateVersionNav();

                    if (!info.exists) {
                        const msg = _versionHistory.length > 0
                            ? 'Current version not on disk. Use the history sidebar to view past versions.'
                            : 'File not found (output not yet generated?)';
                        body.innerHTML = `
                    <div class="file-not-found">
                        <div class="file-not-found-icon">${_versionHistory.length > 0 ? 'üï∞Ô∏è' : 'üîç'}</div>
                        <div class="file-not-found-text">${msg}</div>
                        <div class="file-not-found-path">${filePath}</div>
                    </div>`;
                        return;
                    }

                    // In history mode, auto-jump to the commit version
                    if (_historyCommit && _versionHistory.length > 0) {
                        const histIdx = _versionHistory.findIndex(v => v.hash === _historyCommit);
                        if (histIdx >= 0) {
                            _versionIndex = histIdx;
                            updateVersionNav();
                            await loadVersionContent(_historyCommit);
                            return;
                        }
                    }

                    switch (info.type) {
                        case 'csv': await renderCSV(filePath); break;
                        case 'image': renderImage(filePath); break;
                        case 'pdf': renderPDF(filePath); break;
                        case 'text': await renderText(filePath); break;
                        default:
                            body.innerHTML = `
                        <div class="file-not-found">
                            <div class="file-not-found-icon">üì¶</div>
                            <div class="file-not-found-text">Binary file ‚Äî preview not available</div>
                            <div class="file-not-found-path">${filePath}</div>
                        </div>`;
                    }
                } catch (err) {
                    body.innerHTML = `
                <div class="file-not-found">
                    <div class="file-not-found-icon">üí•</div>
                    <div class="file-not-found-text">Error loading file: ${err.message}</div>
                </div>`;
                }
            }

            // ‚îÄ‚îÄ‚îÄ CSV Renderer ‚îÄ‚îÄ‚îÄ
            let _csvData = null;
            let _csvSortCol = null;
            let _csvSortAsc = true;

            async function renderCSV(filePath) {
                const body = document.getElementById('modal-body');
                const toolbar = document.getElementById('modal-toolbar');
                const search = document.getElementById('modal-search');
                const stats = document.getElementById('modal-stats');

                const res = await fetch(`/api/file/csv?path=${encodeURIComponent(filePath)}`);
                _csvData = await res.json();
                _csvSortCol = null;
                _csvSortAsc = true;

                toolbar.style.display = 'flex';
                stats.textContent = `${_csvData.total} rows √ó ${_csvData.columns.length} cols`;

                // Wire up search
                search.oninput = () => renderCSVTable(search.value.toLowerCase());
                renderCSVTable('');
            }

            function renderCSVTable(filter) {
                const body = document.getElementById('modal-body');
                let rows = _csvData.rows;

                // Filter
                if (filter) {
                    rows = rows.filter(row =>
                        Object.values(row).some(v => (v || '').toLowerCase().includes(filter))
                    );
                }

                // Sort
                if (_csvSortCol !== null) {
                    const col = _csvData.columns[_csvSortCol];
                    rows = [...rows].sort((a, b) => {
                        let va = a[col] || '', vb = b[col] || '';
                        const na = parseFloat(va), nb = parseFloat(vb);
                        if (!isNaN(na) && !isNaN(nb)) return _csvSortAsc ? na - nb : nb - na;
                        return _csvSortAsc ? va.localeCompare(vb) : vb.localeCompare(va);
                    });
                }

                const isNumeric = (val) => val !== '' && !isNaN(parseFloat(val));

                let html = '<div class="csv-table-wrap"><table class="csv-table"><thead><tr>';
                _csvData.columns.forEach((col, i) => {
                    const sorted = _csvSortCol === i;
                    const arrow = sorted ? (_csvSortAsc ? '‚ñ≤' : '‚ñº') : '‚ñ≤';
                    html += `<th class="${sorted ? 'sorted' : ''}" data-col="${i}">${col}<span class="sort-arrow">${arrow}</span></th>`;
                });
                html += '</tr></thead><tbody>';

                const displayRows = rows.slice(0, 500); // Cap display at 500
                for (const row of displayRows) {
                    html += '<tr>';
                    for (const col of _csvData.columns) {
                        const val = row[col] || '';
                        html += `<td class="${isNumeric(val) ? 'numeric' : ''}">${val}</td>`;
                    }
                    html += '</tr>';
                }
                html += '</tbody></table></div>';

                if (rows.length > 500) {
                    html += `<div style="padding:12px 24px;font-size:12px;color:var(--text-muted);">Showing 500 of ${rows.length} rows</div>`;
                }

                body.innerHTML = html;

                // Update stats
                document.getElementById('modal-stats').textContent =
                    filter ? `${rows.length} of ${_csvData.total} rows` : `${_csvData.total} rows √ó ${_csvData.columns.length} cols`;

                // Wire sort clicks
                body.querySelectorAll('.csv-table th').forEach(th => {
                    th.addEventListener('click', () => {
                        const col = parseInt(th.dataset.col);
                        if (_csvSortCol === col) _csvSortAsc = !_csvSortAsc;
                        else { _csvSortCol = col; _csvSortAsc = true; }
                        renderCSVTable(document.getElementById('modal-search').value.toLowerCase());
                    });
                });
            }

            // ‚îÄ‚îÄ‚îÄ Image Renderer ‚îÄ‚îÄ‚îÄ
            function renderImage(filePath) {
                const body = document.getElementById('modal-body');
                body.innerHTML = `<div class="image-viewer"><img src="/api/file/raw?path=${encodeURIComponent(filePath)}" alt="${filePath}"></div>`;
            }

            // ‚îÄ‚îÄ‚îÄ PDF Renderer ‚îÄ‚îÄ‚îÄ
            function renderPDF(filePath) {
                const body = document.getElementById('modal-body');
                body.innerHTML = `<div class="pdf-viewer"><iframe src="/api/file/raw?path=${encodeURIComponent(filePath)}"></iframe></div>`;
            }

            // ‚îÄ‚îÄ‚îÄ Text Renderer ‚îÄ‚îÄ‚îÄ
            async function renderText(filePath) {
                const body = document.getElementById('modal-body');
                const res = await fetch(`/api/file/text?path=${encodeURIComponent(filePath)}`);
                const data = await res.json();

                if (filePath.endsWith('.json')) {
                    try {
                        const parsed = JSON.parse(data.content);
                        body.innerHTML = `<div class="text-viewer">${JSON.stringify(parsed, null, 2)}</div>`;
                    } catch {
                        body.innerHTML = `<div class="text-viewer">${escapeHtml(data.content)}</div>`;
                    }
                } else {
                    body.innerHTML = `<div class="text-viewer">${escapeHtml(data.content)}</div>`;
                }
            }

            function escapeHtml(str) {
                return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }

            // ‚îÄ‚îÄ‚îÄ Modal close ‚îÄ‚îÄ‚îÄ
            document.getElementById('modal-close').addEventListener('click', () => {
                document.getElementById('modal-overlay').classList.remove('visible');
            });
            document.getElementById('modal-overlay').addEventListener('click', (e) => {
                if (e.target === e.currentTarget) {
                    document.getElementById('modal-overlay').classList.remove('visible');
                }
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    document.getElementById('modal-overlay').classList.remove('visible');
                }
            });

            // ‚îÄ‚îÄ‚îÄ Run Pipeline / Stage ‚îÄ‚îÄ‚îÄ
            // selectedStage is declared at top level
            let isRunning = false;
            let stageLogs = {};  // {stageId: 'log lines...'}
            let _errorStages = new Set();  // stages that failed ‚Äî keep red until next run
            let _updatedOutputs = new Set();  // output files produced in last run
            let _stageTimers = {};  // {stageId: {start: Date.now(), duration: ms}}
            let _toastInterval = null;  // interval for live elapsed time in toast
            let _nodeBadgeEls = {};  // {stageId: DOM element} for node overlay badges

            const INSPECTABLE_EXTS = ['.csv', '.tsv', '.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg', '.bmp', '.pdf', '.json', '.yaml', '.yml', '.txt', '.md', '.log', '.jsonl'];
            const isInspectable = (path) => INSPECTABLE_EXTS.some(ext => path.toLowerCase().endsWith(ext));

            // Toast helpers
            function showToast(text, type = 'running') {
                const toast = document.getElementById('exec-toast');
                const spinner = document.getElementById('toast-spinner');
                const icon = document.getElementById('toast-icon');
                document.getElementById('toast-text').textContent = text;

                let cls = 'exec-toast active';
                if (type !== 'running') cls += ' ' + type;
                else cls += ' running';
                toast.className = cls;

                spinner.style.display = type === 'running' ? 'block' : 'none';
                icon.style.display = type !== 'running' ? 'inline' : 'none';
                icon.textContent = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '';

                // Clicking the toast zooms to current running stage
                toast.onclick = () => {
                    if (type === 'running' && _currentRunningStage && cy) {
                        const node = cy.getElementById(_currentRunningStage);
                        if (node.length) {
                            selectedStage = _currentRunningStage;
                            showDetail(node.data());
                            highlightNeighborhood(node);
                            removeNodeBadge(_currentRunningStage);
                            cy.animate({
                                center: { eles: node },
                                zoom: 1.5,
                                duration: 600,
                                easing: 'ease-out-cubic'
                            });
                        }
                    }
                };
            }

            function hideToast() {
                document.getElementById('exec-toast').classList.remove('active');
                if (_toastInterval) { clearInterval(_toastInterval); _toastInterval = null; }
            }

            function formatElapsed(ms) {
                const s = Math.floor(ms / 1000);
                if (s < 60) return `${s}s`;
                const m = Math.floor(s / 60);
                const rs = s % 60;
                if (m < 60) return `${m}m ${rs.toString().padStart(2, '0')}s`;
                const h = Math.floor(m / 60);
                const rm = m % 60;
                return `${h}h ${rm.toString().padStart(2, '0')}m`;
            }

            // ‚îÄ‚îÄ‚îÄ Node badges (floating "NEW" pills on graph) ‚îÄ‚îÄ‚îÄ
            function addNodeBadge(stageId) {
                if (_nodeBadgeEls[stageId]) return;  // already exists
                if (!cy) return;
                const node = cy.getElementById(stageId);
                if (!node.length) return;

                const badge = document.createElement('div');
                badge.className = 'node-badge';
                badge.textContent = 'üîç';
                document.getElementById('node-badges-layer').appendChild(badge);
                _nodeBadgeEls[stageId] = badge;
                positionBadge(stageId);
            }

            function removeNodeBadge(stageId) {
                const badge = _nodeBadgeEls[stageId];
                if (badge) {
                    badge.remove();
                    delete _nodeBadgeEls[stageId];
                }
            }

            function clearAllNodeBadges() {
                for (const id of Object.keys(_nodeBadgeEls)) {
                    removeNodeBadge(id);
                }
            }

            function positionBadge(stageId) {
                const badge = _nodeBadgeEls[stageId];
                if (!badge || !cy) return;
                const node = cy.getElementById(stageId);
                if (!node.length) return;
                const pos = node.renderedPosition();
                const w = node.renderedWidth ? node.renderedWidth() / 2 : 60;
                const h = node.renderedHeight ? node.renderedHeight() / 2 : 20;
                badge.style.left = (pos.x + w) + 'px';
                badge.style.top = (pos.y + h) + 'px';
            }

            function repositionNodeBadges() {
                for (const id of Object.keys(_nodeBadgeEls)) {
                    positionBadge(id);
                }
            }

            // Per-node animation ‚Äî data-driven approach.
            // Uses setInterval + node.data() so updates flow through the
            // Cytoscape stylesheet naturally, avoiding the flicker caused
            // by node.style() bypass fighting with poll-triggered re-renders.
            function startSingleNodeAnimation(stageId) {
                if (!cy) return;
                const node = cy.getElementById(stageId);
                if (!node.length) return;
                // Guard: don't stack animations on the same node
                if (node.scratch('_animating')) return;
                console.log('[ANIM] START', stageId);
                node.scratch('_origBg', node.data('bgColor'));
                node.scratch('_origBorder', node.data('borderColor'));
                node.scratch('_origGlow', node.data('glowColor'));
                node.scratch('_animating', true);

                const startTime = performance.now();
                const PERIOD = 1800; // ms for a full pulse cycle

                const intervalId = setInterval(() => {
                    if (!node.scratch('_animating') || node.removed()) {
                        clearInterval(intervalId);
                        return;
                    }
                    const t = ((performance.now() - startTime) % PERIOD) / PERIOD;
                    const s = (Math.sin(t * Math.PI * 2 - Math.PI / 2) + 1) / 2; // 0..1

                    // Interpolate between dim indigo and bright indigo
                    const bgR = Math.round(30 + s * 19);   // 30 ‚Üí 49
                    const bgG = Math.round(27 + s * 19);   // 27 ‚Üí 46
                    const bgB = Math.round(75 + s * 54);   // 75 ‚Üí 129
                    const brR = Math.round(99 + s * 66);   // 99 ‚Üí 165
                    const brG = Math.round(102 + s * 78);  // 102 ‚Üí 180
                    const brB = Math.round(241 + s * 11);  // 241 ‚Üí 252

                    // Use data() so the stylesheet renders it ‚Äî no bypass flicker
                    node.data({
                        bgColor: `rgb(${bgR}, ${bgG}, ${bgB})`,
                        borderColor: `rgb(${brR}, ${brG}, ${brB})`,
                    });
                }, 50); // ~20fps ‚Äî smooth enough, doesn't overload

                node.scratch('_animIntervalId', intervalId);
            }

            function stopSingleNodeAnimation(stageId, success = true) {
                if (!cy) return;
                const node = cy.getElementById(stageId);
                if (!node.length) return;
                // Stop the interval timer
                const intervalId = node.scratch('_animIntervalId');
                if (intervalId) clearInterval(intervalId);
                node.scratch('_animating', false);
                node.scratch('_animIntervalId', undefined);
                // Restore original color data
                const origBg = node.scratch('_origBg');
                const origBorder = node.scratch('_origBorder');
                const origGlow = node.scratch('_origGlow');
                if (origBg) {
                    node.data('bgColor', origBg);
                    node.data('borderColor', origBorder);
                    node.data('glowColor', origGlow);
                }
                // Clear any leftover bypass styles
                node.removeStyle();
                node.scratch('_origBg', undefined);
                node.scratch('_origBorder', undefined);
                node.scratch('_origGlow', undefined);
                console.log('[ANIM] STOP', stageId);
            }

            async function runPipeline(stage = null) {
                if (isRunning) return;
                isRunning = true;
                _uiLaunchedRun = true;

                const allBtn = document.getElementById('btn-run-all');
                const stageBtn = document.getElementById('btn-run-stage');
                const stopBtn = document.getElementById('btn-stop');
                allBtn.classList.add('running');
                allBtn.disabled = true;
                stageBtn.classList.add('running');
                stageBtn.disabled = true;
                stopBtn.classList.add('visible');

                // Clear previous logs, error states, and updated outputs
                _errorStages.clear();
                _updatedOutputs.clear();
                _stageTimers = {};
                clearAllNodeBadges();
                if (!stage) {
                    stageLogs = {};
                } else {
                    stageLogs[stage] = '';
                }

                const label = stage ? `Running: ${stage}` : 'Running pipeline‚Ä¶';
                showToast(label, 'running');

                // Build SSE URL
                let url = '/api/run-stream?';
                if (stage) url += `stage=${encodeURIComponent(stage)}&`;
                url += 'force=false';

                try {
                    const res = await fetch(url);
                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    let pipelineSuccess = true;
                    let pipelineCancelled = false;
                    let failedStage = null;

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();

                        let eventType = null;
                        for (const line of lines) {
                            if (line.startsWith('event: ')) {
                                eventType = line.slice(7).trim();
                            } else if (line.startsWith('data: ') && eventType) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    handleSSEEvent(eventType, data);
                                } catch (e) { }
                                eventType = null;
                            }
                        }
                    }

                    function handleSSEEvent(type, data) {
                        switch (type) {
                            case 'stage_start':
                                if (!stageLogs[data.stage]) stageLogs[data.stage] = '';
                                _stageTimers[data.stage] = { start: Date.now(), duration: null };
                                // Live elapsed timer in toast
                                if (_toastInterval) clearInterval(_toastInterval);
                                _toastInterval = setInterval(() => {
                                    const t = _stageTimers[data.stage];
                                    if (t && !t.duration) {
                                        const elapsed = formatElapsed(Date.now() - t.start);
                                        _currentRunningStage = data.stage;
                                        document.getElementById('toast-text').textContent = `Running: ${data.stage} (${elapsed}‚Ä¶)`;
                                    }
                                }, 1000);
                                // Note: animation is handled by pollPipeline via running_stage detection
                                break;

                            case 'stage_skip':
                                if (!stageLogs[data.stage]) stageLogs[data.stage] = '';
                                stageLogs[data.stage] += `[skipped ‚Äî no changes]\n`;
                                break;

                            case 'log':
                                if (data.stage && data.line !== undefined) {
                                    if (!stageLogs[data.stage]) stageLogs[data.stage] = '';
                                    stageLogs[data.stage] += data.line + '\n';
                                }
                                if (data.stage && data.stage === selectedStage) {
                                    const logPre = document.querySelector('.sidebar-logs-content');
                                    if (logPre) {
                                        logPre.textContent = stageLogs[data.stage];
                                        logPre.scrollTop = logPre.scrollHeight;
                                    }
                                }
                                break;

                            case 'stage_done':
                                if (_stageTimers[data.stage]) {
                                    _stageTimers[data.stage].duration = Date.now() - _stageTimers[data.stage].start;
                                }
                                if (_toastInterval) { clearInterval(_toastInterval); _toastInterval = null; }
                                if (!data.success) {
                                    pipelineSuccess = false;
                                    failedStage = data.stage;
                                    _errorStages.add(data.stage);
                                }
                                // Mark outputs as updated for badge display
                                if (data.success && cy) {
                                    const n = cy.getElementById(data.stage);
                                    if (n.length) {
                                        const allFiles = [...(n.data('outs') || []), ...(n.data('metrics') || []), ...(n.data('plots') || [])];
                                        allFiles.forEach(o => {
                                            const p = typeof o === 'string' ? o : o.path;
                                            if (p) _updatedOutputs.add(p);
                                        });
                                        if (allFiles.some(o => { const p = typeof o === 'string' ? o : o.path; return p && isInspectable(p); })) {
                                            addNodeBadge(data.stage);
                                        }
                                    }
                                }
                                break;

                            case 'done':
                                pipelineSuccess = data.success;
                                pipelineCancelled = data.cancelled || false;
                                if (data.failed_stage) failedStage = data.failed_stage;
                                break;
                        }
                    }

                    // Final toast
                    if (pipelineSuccess) {
                        showToast('Pipeline completed ‚úì', 'success');
                    } else if (pipelineCancelled) {
                        showToast('Pipeline cancelled ‚úó', 'error');
                    } else {
                        showToast(`Failed: ${failedStage || 'unknown stage'}`, 'error');
                    }
                    setTimeout(hideToast, 4000);
                    // Note: state cleanup is handled by pollPipeline detecting is_running ‚Üí false

                } catch (err) {
                    showToast('Error: ' + err.message, 'error');
                    setTimeout(hideToast, 5000);
                    _uiLaunchedRun = false;
                    isRunning = false;
                }
            }

            // Run All button
            document.getElementById('btn-run-all').addEventListener('click', () => runPipeline(null));

            // Run Stage button
            document.getElementById('btn-run-stage').addEventListener('click', () => {
                if (selectedStage) runPipeline(selectedStage);
            });

            // Stop button
            document.getElementById('btn-stop').addEventListener('click', async () => {
                try {
                    await fetch('/api/stop', { method: 'POST' });
                    // Immediately stop all animations and reset UI state
                    if (cy) cy.nodes().forEach(n => {
                        if (n.scratch('_animating')) {
                            stopSingleNodeAnimation(n.id());
                        }
                    });
                    isRunning = false;
                    const allBtn = document.getElementById('btn-run-all');
                    const stageBtn = document.getElementById('btn-run-stage');
                    const stopBtn = document.getElementById('btn-stop');
                    allBtn.classList.remove('running');
                    allBtn.disabled = false;
                    stageBtn.classList.remove('running');
                    stageBtn.disabled = false;
                    stopBtn.classList.remove('visible');
                    _prevIsRunning = false;
                    _prevRunningStage = null;
                    _uiLaunchedRun = false;
                    showToast('Pipeline stopped ‚úó', 'error');
                    setTimeout(hideToast, 4000);
                } catch (e) {
                    console.error('Failed to stop pipeline:', e);
                }
            });

            // ‚îÄ‚îÄ‚îÄ Commit Navigation Logic ‚îÄ‚îÄ‚îÄ
            function updateCommitNav() {
                if (_commitList.length === 0) return;
                const commit = _commitList[_commitIndex];
                const hashEl = document.getElementById('commit-hash');
                const msgEl = document.getElementById('commit-msg');
                const badgeEl = document.getElementById('commit-badge');
                const olderBtn = document.getElementById('commit-older');
                const newerBtn = document.getElementById('commit-newer');

                hashEl.textContent = commit.short_hash;
                msgEl.textContent = commit.message;
                msgEl.title = `${commit.message} ‚Äî ${commit.author} (${commit.date})`;

                olderBtn.disabled = _commitIndex >= _commitList.length - 1;
                newerBtn.disabled = _commitIndex <= 0;

                if (_commitIndex === 0) {
                    badgeEl.textContent = 'HEAD';
                    badgeEl.className = 'commit-badge-head';
                } else {
                    badgeEl.textContent = 'HISTORY';
                    badgeEl.className = 'commit-badge-history';
                }
            }

            async function navigateToCommit(index) {
                if (index < 0 || index >= _commitList.length) return;
                _commitIndex = index;
                updateCommitNav();

                if (index === 0) {
                    // Return to HEAD ‚Äî live mode
                    _isHistoryMode = false;
                    document.body.classList.remove('history-mode');
                    const data = await fetchPipeline();
                    if (!data.error) {
                        _pipelineData = data;
                        const elements = buildElements(data);
                        initGraph(elements);
                        updateStats(data);
                        renderNodeList(data);
                    }
                    startPolling();
                } else {
                    // History mode ‚Äî load pipeline at this commit
                    _isHistoryMode = true;
                    document.body.classList.add('history-mode');
                    stopPolling();

                    const commit = _commitList[index];
                    try {
                        const res = await fetch(`/api/pipeline/at-commit?commit=${commit.hash}`);
                        const data = await res.json();
                        if (data.error) {
                            showToast(`Error: ${data.error}`, 'error');
                            setTimeout(hideToast, 4000);
                            return;
                        }
                        _pipelineData = data;
                        const elements = buildElements(data);
                        initGraph(elements);
                        updateStats(data);
                        renderNodeList(data);
                    } catch (e) {
                        showToast(`Failed to load commit: ${e.message}`, 'error');
                        setTimeout(hideToast, 4000);
                    }
                }
            }

            document.getElementById('commit-older').addEventListener('click', () => {
                navigateToCommit(_commitIndex + 1);
            });

            document.getElementById('commit-newer').addEventListener('click', () => {
                navigateToCommit(_commitIndex - 1);
            });

            boot();

            // ‚îÄ‚îÄ‚îÄ Sidebar resize ‚îÄ‚îÄ‚îÄ
            (function () {
                const handle = document.getElementById('sidebar-resize');
                const sidebar = document.getElementById('sidebar');
                let startX, startW;

                // Add search listener
                const searchInput = document.getElementById('sidebar-search');
                if (searchInput) {
                    searchInput.addEventListener('input', () => {
                        if (_pipelineData) renderNodeList(_pipelineData);
                    });
                }

                // Add status filter listener
                const statusFilter = document.getElementById('sidebar-status-filter');
                if (statusFilter) {
                    statusFilter.addEventListener('change', () => {
                        if (_pipelineData) renderNodeList(_pipelineData);
                    });
                }

                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    startX = e.clientX;
                    startW = sidebar.offsetWidth;
                    handle.classList.add('active');
                    sidebar.style.transition = 'none';

                    function onMove(e) {
                        const delta = startX - e.clientX;
                        const newW = Math.min(Math.max(startW + delta, 260), window.innerWidth * 0.8);
                        sidebar.style.width = newW + 'px';
                    }

                    function onUp() {
                        handle.classList.remove('active');
                        sidebar.style.transition = '';
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                        // Resize cytoscape
                        if (cy) cy.resize();
                    }

                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                });
            })();
        })();
    </script>
</body>

</html>